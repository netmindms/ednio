{"name":"Ednio","tagline":"Event Driven Non Block IO Task Library for C++","body":"ednio\r\n=====\r\n\r\n# Event Driven Non Block IO Task Library for C++\r\n\r\nOverview\r\n--------\r\n\r\nednio is a simple C++ library that provides event driven scheme on thread.\r\n\r\nThis provides as follwing features.\r\n\r\n- Event Driven Task having event loop and default event callback procedure.\r\n- Easy non block socket API\r\n- Easy Timer API that notify expiration asynchronously.\r\n- Easy non block mode pipe API\r\n\r\nHow to build\r\n------------\r\n\r\nTo build the sources, you need scons build tool. \r\nOn Ubuntu, you can install it as following.\r\n\r\n\t$ sudo apt-get install scons\r\n\r\nIn case of other Linux, refer to scons.org of official scons home page.\r\n\r\nAfter you install scons, you just enter follwing command on top folder of source to build\r\n\r\n\t$ scons\r\n\r\n\r\nTypical Usage\r\n-------------\r\n- make your own event driven task by inheriting EdTask class and override OnEventProc() to capture events.\r\n- write initial codes on code block processing EDM_INIT event. EDM_INIT message is sent by ednio framework when task just start.\r\n- Add your specific messages by defining message id since EDM_USER\r\n- call EdTask::run() to start task.\r\n- write cleanup codes on code block processing EDM_CLOSE. EDM_CLOSE message is sent by ednio framework before task terminates.\r\n\r\n\r\nSocket, Timer, Pipe\r\n-------------------\r\nednio API basically run asynchronously with non block IO.\r\nIt means that you has your codes not blocked with best effort.\r\nOtherwise, events on task(thread) will be delayed.\r\nednio socket, timer, pipe APIs run on non block mode.\r\nYou can get their events as two styles.\r\n\r\nFirst, Use call back interface.\r\nCallback interface is an instance of callback abstract class of socket, timer, pipe.\r\n\r\nSecond, Override OnXXX virtual functions of each event classes.\r\n\r\nTo understand detail, refer to example codes.\r\n\r\nTask\r\n----\r\nTo use ednio event driven APIs, you should make one EdTask at least.\r\nEdTask is a thread having event dispatch loop.\r\nIt is responsible for monitoring events and triggering callback for each event.\r\nEdTask has its own specific event dispatching loop. But if you want, you can use libevent in place of ednio event loop. This libevent compatible mode is useful in case you should use any opensource library dependent on libevent.(For example, hiredis library)\r\nTo make EdTask run with libevent, call EdTask::run(MODE_LIBEVENT).\r\nAlso, You need to build sources with following build argument.\r\n\r\n\t$ scons libevent=true\r\nMake sure that libevent library is installed on your system in advance as well.\r\n\r\n\r\n\r\nIPC between EdTasks\r\n-------------------\r\nednio allows to make some instances of EdTask.\r\nIf you want to communicate between tasks, you can use EdTask::postMsg() or EdTask::sendMsg().\r\npostMsg return immediately after adding the message to que. But sendMsg wait until the message is processed by target task.\r\nNever call sendMsg on the same task(that is, target task), Doing so causes permanent dead-lock on that task.\r\n\r\n\r\nThread safe and Thread Local Storage\r\n------------------------------------\r\nMost of ednio API are not thread-safe.(except sendMsg and postMsg)\r\nIt is intenional in designe concept. \r\nI believe the best solution for thread sychronization problem is not making the situation which synchronization is needed.\r\nednio prefers single-thread, multi-instance model.\r\nEdEvent classes(EdSocket, EdTimer, EdPipe) refer context object stored in thread local storage to determine to run on which task. Therefore, If you opened an event object on A EdTask, callback will be on A EdTask. Also, it is not a good choice to refer event object directly on other task. If you need the situation, use IPC functions.\r\n\r\n\r\nToDo\r\n----\r\n- Support Non Block Mode SSL Socket \r\n- Support Non Block Mode libcurl\r\n- Support Non Block Mode DB Client.\r\n\r\n\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}